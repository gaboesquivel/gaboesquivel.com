---
title: Modern Next.js Web3 Architecture
publishedAt: 2024-10-01
summary: Building scalable Web3 apps with Next.js
image: /images/2024/10/nextjs-web3-architecture.webp
---

In the rapidly evolving landscape of Web3 development, creating efficient, scalable, and user-friendly applications is crucial. This guide outlines a modern architecture for building Web3 applications using Next.js, incorporating best practices and optimizations for performance and maintainability.


{/* Prevent CLS by setting a minimum height */}
<div style={{ minHeight: '300px' }}>
![Next.js Web3 Architecture](/images/2024/10/nextjs-web3-architecture.webp)
</div>



## Architectural Principles

1. URL-based state management
2. Efficient data handling with API reads and EVM transaction writes
3. Optimized data fetching using React Query
4. Feature-based code organization
5. Pragmatic abstraction (AHA Programming)

Let's dive deeper into each of these principles.


### Code Collocation

Code collocation is a principle in React development that emphasizes organizing code by feature or functionality rather than by file type. This approach, championed by Kent C. Dodds and others in the React community, offers several benefits:

1. **Improved Maintainability**: By keeping related code close together, it's easier to understand and modify features.
2. **Better Scalability**: As your application grows, collocated code remains manageable and doesn't spread across multiple directories.
3. **Faster Development**: Developers can focus on one feature at a time without jumping between different files and folders.
4. **Easier Refactoring**: When code is collocated, it's simpler to extract or move features as needed.

In practice, code collocation in React might look like this:

- Instead of separate directories for components, styles, and tests, you might have a feature-based structure.
- Related components, hooks, utilities, and tests are kept in the same directory.

For a more detailed explanation and examples, refer to Kent C. Dodds' article on the subject: [Colocation](https://kentcdodds.com/blog/colocation).

### Managing State with URLs

Relying on URLs for state changes in Next.js enhances user experience by preserving application state across page reloads and enabling easy sharing. This approach is particularly useful for managing user settings, filters, and other dynamic data.

Benefits of URL-Based State Management:

1. **Persistence**: State information encoded in the URL survives page refreshes, crucial for applications where users may navigate away and return later.
2. **Shareability**: Users can share specific application states via URLs, allowing direct access to particular views or settings.
3. **SEO Advantages**: Canonical URLs help search engines understand which version of a page should be indexed, preventing duplicate content issues.


### One Subscription per Route

Implementing a single subscription for each route in your API architecture offers several advantages:

1. **Reduced Connection Overhead**: Fewer active connections lead to improved performance and lower latency.
2. **Simplified Management**: Easier to implement changes and troubleshoot issues with fewer subscriptions.
3. **Streamlined Traffic Management**: More efficient handling of requests and responses, optimizing resource allocation.

Cached Queries

Singleton instances of queries are a powerful optimization technique that reduces server connections and improves data consistency across components. This approach is particularly beneficial when multiple components require the same data, allowing them to share a single query instance.

Benefits of Cached Queries:

1. **Reduced Server Load**: By minimizing redundant API calls, singleton queries decrease the overall load on your server.
2. **Improved Performance**: Fewer network requests lead to faster page loads and a smoother user experience.
3. **Consistent Data**: All components access the same data instance, ensuring consistency throughout the application.
4. **Efficient Caching**: Centralized data management simplifies cache invalidation and updates.

Implementation with React Query:

React Query provides built-in support for singleton queries through its intelligent caching mechanism. The query key acts as a unique identifier:

Key aspects of React Query's caching behavior:

1. **Caching**: Identical query keys return cached data, avoiding unnecessary API calls.
2. **Smart Refetching**: React Query automatically refetches stale data or when specific conditions are met (e.g., window focus, network reconnection).
3. **Shared State**: Components using the same query key share data and loading states.
4. **Automatic Deduplication**: Simultaneous requests for the same data are consolidated into a single API call.

Best Practices:

1. **Consistent Query Keys**: Use a standardized format for query keys to ensure proper caching and deduplication.
2. **Granular Keys**: Include relevant parameters in the query key for precise cache management.
3. **Global Queries**: For app-wide data, consider initializing queries at the root level.
4. **Prefetching**: Utilize React Query's prefetching capabilities to load data before it's needed.

By leveraging cached queries effectively, you can significantly optimize your application's data fetching strategy, leading to improved performance and a better user experience.


### Pragmatic Abstraction (AHA Programming)

Pragmatic Abstraction, often referred to as AHA Programming, is a development philosophy that emphasizes simplicity and practicality in software design. It encourages developers to avoid unnecessary complexity and to focus on creating solutions that are both effective and easy to understand.

Key Principles:

1. **Avoid Premature Optimization**: Start with a simple and clear solution, and only optimize when necessary.
2. **Keep It Simple**: Use straightforward approaches that are easy to understand and maintain.
3. **Focus on the Problem**: Concentrate on solving the problem at hand rather than creating a more complex solution.
4. **Use Standard Libraries**: Leverage well-established libraries and patterns that have proven track records.
5. **Avoid Over-Engineering**: Resist the urge to create overly complex designs that may be harder to maintain.

Benefits:

1. **Simplicity**: AHA programming leads to simpler, more understandable code.
2. **Maintainability**: Code that is easy to understand is easier to maintain.
3. **Flexibility**: Simpler designs are more flexible and can adapt to changes more easily.

