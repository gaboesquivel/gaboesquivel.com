---
title: Intent-Based Multichain DeFi
publishedAt: 2025-10-15
summary: How intent-based architecture is solving the multichain coordination problem—and why solver networks are the new primitive
image: /images/2025/10/multichain-defi-intents.webp
category: ['Web3', 'DeFi']
tech: ['Web3', 'DeFi', 'Intents', 'Multichain', 'EVM', 'Ethereum', 'Solana', 'Cosmos']
---

As a full‑stack engineer building across EVM, Solana, and Cosmos ecosystems, I've watched the multichain coordination problem evolve from "bridge and pray" to something far more elegant: **intent-based architecture**. Instead of users manually orchestrating transactions across chains—bridge here, swap there, deposit somewhere else—they now sign a single statement expressing their desired outcome, and specialized solver networks compete to fulfill it.

This isn't speculative anymore. CoW Protocol has posted $10B+ in monthly volume multiple times this year. UniswapX is processing billions in gasless, MEV-protected swaps across Ethereum and L2s. Across Protocol handles thousands of cross-chain fills daily with sub-minute latency. Jupiter on Solana routes $2B+ per day through competing market makers. These are production systems moving real capital—and they're all converging on the same model: **outcomes, not instructions**.

{/* Prevent CLS by setting a minimum height */}
<div style={{ minHeight: '300px' }}>
![Intent-Based Multichain DeFi](/images/2025/10/multichain-defi-intents.webp)
</div>

## The multichain coordination problem

If you've built any cross‑chain feature in the last few years, you know the pain: Users want to move 1 ETH from Arbitrum into a yield position on Base. The old path looks like:

1. Bridge ETH from Arbitrum to Base (wait 10 minutes, pay gas)
2. Swap ETH → USDC on Base (pay gas, risk slippage)
3. Deposit USDC into yield vault (pay gas again)

Three transactions, three approvals, three gas payments, three opportunities for user error or sandwich attacks. If the user doesn't have gas on the destination chain, they're stuck. If liquidity shifts between steps, they get worse pricing than they expected. If they screw up step 2, they're holding tokens they didn't want on a chain they don't use.

**Intents collapse this into a single signed message**: "I have 1 ETH on Arbitrum; I want yield-bearing USDC on Base." Solver networks compete to fulfill it—finding the best route, fronting capital for instant fills, sponsoring gas, and settling the result onchain. The user signs once and gets the outcome they asked for. That's the shift.

## What are intents?

An **intent** is a signed, declarative statement of desired outcome plus constraints. For example:

> "Swap 1 ETH on Arbitrum for at least 3,000 USDC on Base, filled within 60 seconds."

It doesn't say **how**—it just defines **what** success looks like. Solvers (specialized actors, often market makers or relayers) compete to fulfill the intent by:

* Finding optimal liquidity across AMMs, RFQ venues, CEX APIs, private inventory
* Fronting capital for instant settlement (avoiding slow bridge delays)
* Sponsoring gas on destination chains
* Shielding users from MEV, reverts, and slippage

Once a solver commits to fulfill the intent, the execution is settled onchain—either atomically or via cryptographic proofs (depending on whether it's same-chain or cross-chain).

### Why intents matter for multichain

The magic is this: **intents decouple user goals from execution paths**. Users don't need to know which bridge is fastest, which DEX has the best liquidity, or how to navigate gas tokens on five different chains. They just express what they want—and solvers handle the complexity.

This is a huge unlock for multichain UX. It means:

* **No pre-funding gas on destination chains** (solvers sponsor it)
* **No liquidity fragmentation** (solvers aggregate across all venues)
* **No slow bridge UX** (solvers front capital for instant fills)
* **No MEV exposure** (intents are auctioned offchain, not broadcast to public mempools)

For product engineers, this means you can now build **chain-agnostic features** without forcing users to become multichain infrastructure experts.

## Architecture: how it works

At a high level, intent-based systems follow this pattern:

1. **User** signs an offchain intent (usually EIP-712 or EIP-1271 signatures)
2. **Intent mempool** (or relay network) broadcasts the intent to competing solvers
3. **Solvers** compute optimal execution paths and bid to fulfill the intent
4. **Settlement contract** verifies the solver's fulfillment and releases funds

The key insight: **computation happens offchain, verification happens onchain**. This inverts the traditional model where users broadcast transactions with full execution logic to the mempool. Instead, solvers do the heavy lifting privately, and only the winning solution gets settled onchain.

### Same-chain vs. cross-chain intents

**Same-chain intents** (e.g., swap ETH → USDC on Ethereum) are simpler: the solver submits a single transaction to a settlement contract, which verifies constraints and executes atomically.

**Cross-chain intents** are harder: the solver must prove fulfillment on the destination chain and trigger settlement on the source chain (or vice versa). This requires either:

* **Message-passing** (via Wormhole, Axelar, LayerZero)
* **Optimistic fulfillment** (solver fronts capital, waits for proof)
* **Compact settlement** (via ERC-6909-style reusable commitments)

The latest protocols (Across, Wormhole Composable Intents, deBridge DLN) are production-hardened for cross-chain fills—often achieving sub-minute finality with no bridge UX.

## Production protocols by ecosystem

Let's break down what's actually live and moving volume.

### EVM: same-chain intent protocols

* **UniswapX**: Dutch auction–based intent protocol. Users sign an intent; fillers compete with descending price curves until someone fills it. Gasless for users. MEV-protected. Aggregates Uniswap liquidity + RFQ + private inventory. Now live on Mainnet, Arbitrum, Polygon, Base.

* **CoW Protocol**: Batch auction model. Multiple intents are collected into a batch; solvers compete to find the optimal settlement across all orders (maximizing user surplus, minimizing MEV). Particularly strong for large trades and toxic flow mitigation. Regularly posts $10B+ monthly volume.

* **1inch Fusion+**: Resolver-based intent execution. Supports gasless swaps, partial fills, and cross-chain routing. Resolvers tap into 1inch's aggregation engine plus private liquidity sources.

These aren't experiments—they're handling billions in monthly volume with better pricing than traditional AMM routing.

### EVM: cross-chain intent protocols

* **Across Protocol**: Fast cross-chain fills using capital-efficient "spoke pool" design. Relayers front liquidity on destination chains and get reimbursed via canonical bridges. Sub-minute fills, tight spreads, EVM-native. One of the most reliable cross-chain intent protocols in production.

* **Wormhole (Era 3)**: Composable Intents enable any-to-any cross-chain actions with a single signed message. Wormhole's message-passing infrastructure handles settlement across EVM, Solana, Cosmos, and more. This is the closest thing we have to universal intent composability.

* **Socket / LI.FI**: Intent orchestration layers that aggregate multiple bridging and swap protocols. They abstract solver selection, route optimization, and settlement verification—letting apps integrate cross-chain intents via a single API.

### Solana: outcome-first routing

Solana's architecture (single global state, 400ms slots) makes intent-based execution *easier* than on EVM. No mempool sniping, no gas wars—just competing routers submitting bids to fulfill user intents.

* **Jupiter**: The dominant Solana aggregator. Outcome-first routing via competing market makers and routers. Users express desired swaps; Jupiter finds the best path across AMMs + RFQ + private liquidity. Regularly handles $2B+ daily volume.

* **Mayan Swift**: Cross-chain intent fills between Solana and EVM chains. Uses auction-based matching with Wormhole settlement. Enables "I want SOL on Solana, I have USDC on Arbitrum" flows with sub-minute fills.

### Cosmos / IBC: intent-native routing

Cosmos IBC is *designed* for cross-chain coordination, but UX has traditionally required users to understand relayers, channels, and multi-hop routing. Intent-based protocols are changing that.

* **Skip Protocol**: Intent-based bridging and routing across Cosmos chains. Users sign a single message; Skip's solver network finds optimal IBC paths, handles gas, and settles cross-chain. Feels like same-chain UX.

* **Axelar + Squid**: Cross-chain liquidity via Axelar's message-passing network. Squid's intent layer lets users express "I want asset X on chain Y"—solvers front capital, Axelar settles the proof. Tight integration with both EVM and Cosmos.

### Universal cross-chain: message-based protocols

* **Wormhole Composable Intents**: Universal intent execution across all Wormhole-connected chains (Ethereum, Solana, Cosmos, Sui, Aptos). Single signed message can orchestrate multi-step, multi-chain actions. This is the endgame for chain-agnostic DeFi.

* **deBridge DLN (Defi Liquidity Network)**: RFQ-style intent fulfillment with *no pooled liquidity*. Solvers front their own capital, compete on price, and get reimbursed via canonical bridges. Low latency, no TVL risk.

### Quick protocol selection guide

If you're building a multichain feature today, here's how to choose:

* **EVM same-chain swaps**: UniswapX or CoW Protocol
* **EVM cross-L2 (Arbitrum ↔ Base, etc.)**: Across Protocol
* **Solana-only swaps**: Jupiter
* **Solana ↔ EVM**: Wormhole + Mayan Swift
* **Cosmos-first**: Skip Protocol
* **EVM ↔ Cosmos**: Axelar + Squid
* **Universal (EVM + Solana + Cosmos)**: Wormhole Composable Intents
* **RFQ-style, no-TVL risk**: deBridge DLN

## Standards: ERC-7683 and the Open Intents Framework

One of the biggest developments in 2025 is the emergence of **ERC-7683**, an open standard for expressing and fulfilling cross-chain intents. It defines:

* A common **intent format** (what the user wants, what constraints apply)
* A **fulfillment interface** (how solvers prove they satisfied the intent)
* A **settlement flow** (how funds are released once fulfillment is verified)

The **Open Intents Framework (OIF)** builds on ERC-7683 with shared contracts, SDK tooling, and solver infrastructure. Major L2s (Arbitrum, Optimism, Base) and wallets (Coinbase Wallet, Rabby) are adopting OIF conventions, which means:

* Intents are portable across chains and protocols
* Solvers can fulfill intents from any OIF-compliant source
* Apps can integrate intent-based UX without custom per-chain logic

This standardization is critical. Without it, every protocol would have its own intent format, and solver networks couldn't interoperate. ERC-7683 is doing for intents what ERC-20 did for tokens.

### ERC-6909 (Compacts): reusable cross-chain commitments

**ERC-6909 (Compacts)** is a newer primitive that enables **capital-efficient cross-chain intents**. Instead of locking liquidity in per-chain pools, compacts let solvers commit capital *once* and reuse it across many intents and chains.

Here's the pattern:

1. Solver locks collateral in a compact contract
2. User signs an intent referencing that compact
3. Solver fulfills the intent on the destination chain
4. Compact contract verifies fulfillment and releases the collateral

This is more capital-efficient than traditional bridge pools, and it enables instant settlement without waiting for slow canonical bridges. Compacts are gaining traction in newer aggregator stacks (Socket, LI.FI) and will likely become standard in 2026.

## MEV and privacy: intents as MEV mitigation

One of the underrated benefits of intent-based execution is **MEV protection**. Traditional DeFi transactions are broadcast to public mempools, where searchers can:

* Front-run (buy before you)
* Sandwich (buy before, sell after)
* Backrun (exploit price impact you created)

**Intents invert this**. Because the user only signs a declarative statement (not executable calldata), there's no transaction to front-run *until a solver commits to fulfilling it*. And because solvers compete *offchain* (in private auctions or batches), the winning execution path isn't public until it's already settled onchain.

This doesn't eliminate MEV—it shifts it. Solvers still extract value by finding optimal routes and capturing spread. But toxic MEV (sandwich attacks, front-running) is mitigated because users never expose their execution intent to the mempool.

### Adding privacy layers

For maximum privacy, some protocols are adding **encrypted intent mempools** or **trusted execution environments (TEEs)**. Examples:

* **SUAVE** (from Flashbots): Decentralized block-building with encrypted mempools. Intents can be routed through SUAVE to hide user data until execution.
* **Anoma**: A purpose-built L1 for private, intent-based coordination. Uses zero-knowledge proofs to hide trade details from solvers until settlement.

If you're building high-value trading features (large swaps, liquidations, arbitrage), routing intents through privacy-preserving infrastructure should be part of your security model.

## Product and engineering implications

What does this mean for teams building multichain apps?

### 1. You can now build chain-agnostic UX

Users shouldn't need to know which chain your protocol is on. With intent-based architecture, you can abstract that completely:

* "Deposit $1,000 into yield vault" → solver figures out the chain, liquidity path, and gas
* "Swap my tokens for ETH" → solver routes across any chain with the best price
* "Send $500 to Alice" → solver picks the cheapest route, fronts liquidity, settles instantly

This is a **massive UX improvement** over "first bridge to Chain X, then swap on DEX Y, then approve and deposit."

### 2. Gas sponsorship becomes default

Because solvers compete to fulfill intents, they can sponsor gas as part of their service (and recoup costs via spread or fees). This means:

* Users don't need gas tokens on every chain
* Onboarding flows are simpler (no "get gas first" step)
* Cross-chain actions feel instant (no waiting for bridge + manual swaps)

If you're building consumer-facing DeFi, **gasless UX via intents** should be table stakes in 2026.

### 3. Liquidity aggregation is automatic

Solvers have access to all liquidity sources (AMMs, RFQ venues, CEXs, private inventory). This means your app automatically benefits from:

* Better pricing (solvers find the best route)
* Deeper liquidity (aggregated across venues)
* Lower reverts (solvers simulate execution before committing)

You don't need to integrate ten different DEX aggregators—just plug into an intent protocol and let solvers handle routing.

### 4. MEV-aware design becomes easier

Instead of building custom MEV protection (private mempools, batching, etc.), you inherit it from the intent protocol. CoW's batch auctions, UniswapX's Dutch auctions, and Across's relayer network all have MEV mitigation baked in.

For engineers: **use intents as your MEV boundary**. Don't expose raw transactions to public mempools—let users sign intents and let solvers compete privately.

### 5. Agentic finance and AI-driven intents

Intents are a perfect fit for **agentic finance**—where AI agents execute financial actions on behalf of users. As I wrote in my [Agentic Finance](/blog/2025-09-agentic-finance) post, agents need deterministic, constraint-based execution models to operate safely. Intents provide exactly that:

* The user (or agent) defines the goal and constraints
* The solver (or protocol) finds the optimal execution path
* Settlement is verified cryptographically onchain

Protocols like Olas, Autonolas, and emerging AI agent frameworks are already using intent-based execution as their coordination layer. If you're building AI × DeFi features, **intents should be your primitive**.

## Builder checklist (November 2025)

If you're integrating intent-based execution into your app, here's what to prioritize:

* **Standardize on ERC-7683 and EIP-712 signatures** for maximum interoperability
* **Choose your execution model**: Dutch auction (UniswapX), batch auction (CoW), resolver (1inch), or relayer (Across)
* **Use ERC-6909 compacts** if you need capital-efficient cross-chain settlement
* **Route through privacy layers** (SUAVE, Anoma) if your users need MEV protection
* **Support ERC-4337 / ERC-7702 wallets** for seamless gasless UX
* **Integrate OIF tooling** (SDK, solver APIs, settlement contracts) to speed up launch

The intent stack is mature enough now that you don't need to build from scratch—there are production-ready SDKs, solver networks, and settlement infrastructure.

## What to watch in 2026

The intent-based architecture is still evolving. Here's what I'm tracking:

* **ERC-7683 adoption across L2s and wallets**: Will this become the standard, or will we see competing formats?
* **ERC-6909 compacts in production**: Can capital-efficient cross-chain settlement scale to billions in daily volume?
* **Solver network consolidation**: Will a few dominant solver networks emerge, or will we see specialized solvers per use case?
* **AI agent adoption**: How quickly will agentic finance protocols adopt intent-based execution?
* **Privacy-preserving intent mempools**: Will encrypted intent pools (SUAVE, Anoma) become standard for high-value flows?

## My conclusion: why I'm building with intents

I've been building multichain features since 2021—back when "cross-chain" meant manually bridging and praying liquidity existed on the destination chain. Intent-based architecture has changed that completely.

Today, I can build apps where users express what they want—and solver networks handle the messy coordination across chains, liquidity venues, and gas tokens. The UX is better. The pricing is better. The security is better (MEV mitigation, no reverts). And the code is simpler (no custom bridge integrations, no multi-step transaction flows).

If you're building multichain DeFi in 2025-2026, **start with intents**. Don't force users to think in transactions—let them think in outcomes. The solver networks are production-ready. The standards are converging. The infrastructure is here.

Your edge isn't *which chain you build on*—it's **how well you leverage solver networks to fulfill user intent**.

## Suggested videos and resources

* [UniswapX Explained – Bankless](https://www.youtube.com/watch?v=PA45L8HGL3E)
* [How CoW Protocol Works – Finematics](https://www.youtube.com/watch?v=1ACCCB1wptI)
* [Wormhole's Vision for Composable Intents – Wormhole Summit](https://www.youtube.com/watch?v=0K9zG7jAyDw)
* [ERC-7683 and OIF Deep Dive – EthGlobal](https://www.youtube.com/watch?v=tXJZIXU2ChA)
* [Across Protocol Architecture](https://docs.across.to/)
* [Skip Protocol: Intent-Based IBC](https://skip.money/)
